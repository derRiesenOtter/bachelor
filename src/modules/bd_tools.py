import itertools
import pickle
import unittest
from collections import Counter

import numpy as np


def get_scalar_values_rsa(
    id: str, sequence: np.ndarray, mapping: dict, rsa: str = "rsa"
) -> dict:
    """
    Modifies the output of the blockdecomposition algorithm
    to be used as tabular data. Includes rsa data.
    :param sequence: Mapped protein sequence as np.ndarray
    :type sequence: np.ndarray
    :param mapping: One of the mappings used in the block
    decomposition algorithm
    :type mapping: dict
    :param rsa: Name of the column that contains the rsa values
    :type rsa: str
    :return: Dictionary of all allowed combinations of groups as keys
    and their fraction in the protein as values
    :rtype: dict
    """
    dic = {}
    for _, value in mapping.items():
        dic[value] = 0
    permutations = itertools.permutations(dic.keys(), 2)
    for value in permutations:
        new_key = int(str(value[0]) + str(value[1]))
        dic[new_key] = 0
    dic[9] = 0
    dic[-1] = 0
    with open("./data/intermediate_data/pspire_rsa.pkl", "rb") as f:
        rsa_df = pickle.load(f)
    rsa_seq = rsa_df[rsa_df["UniprotEntry"] == id][rsa].iloc[0]
    rsa_gt_025 = 0
    for residue, rsa_residue in zip(sequence, rsa_seq):
        if rsa_residue > 0.25:
            rsa_gt_025 += 1
            dic[int(residue)] = dic[int(residue)] + 1
    for key in dic.keys():
        dic[key] = dic[key] / rsa_gt_025
    return dic


def get_scalar_values(sequence: np.ndarray, mapping: dict) -> dict:
    """
    Modifies the output of the blockdecomposition algorithm
    to be used as tabular data.
    :param sequence: Mapped protein sequence as np.ndarray
    :type sequence: np.ndarray
    :param mapping: One of the mappings used in the block
    decomposition algorithm
    :type mapping: dict
    :return: Dictionary of all allowed combinations of groups as keys
    and their fraction in the protein as values
    :rtype: dict
    """
    dic = {}
    for _, value in mapping.items():
        dic[value] = 0
    permutations = itertools.permutations(dic.keys(), 2)
    for value in permutations:
        new_key = int(str(value[0]) + str(value[1]))
        dic[new_key] = 0
    dic[9] = 0
    dic[-1] = 0
    for residue in sequence:
        dic[int(residue)] = dic[int(residue)] + 1
    for key in dic.keys():
        dic[key] = dic[key] / len(sequence)
    return dic


def get_block_seq(
    sequence: str, block_list: list[tuple[int, int]], mapping: dict
) -> np.ndarray:
    """
    Modifies the output of the block decomposition algorithm to be more useful
    for neural network model training.

    :param sequence: Protein Sequence as String
    :type sequence: str
    :param block_list: Block List generated by the block decomposition
    algorithm.
    :type block_list: list[tuple[int, int]]
    :param mapping: Mapping used for the block decomposition.
    :type mapping: dict
    :return: Array that represents the block decomposition, were every block is
    a part of the sequence with its label.
    :rtype: np.ndarray
    """
    block_seq = np.repeat(-1, len(sequence))
    mapped_sequence = map_sequence(sequence, mapping)
    for block in block_list:
        block_start = block[0]
        block_end = block[1]
        label = get_label(mapped_sequence[block_start:block_end])
        block_seq[block_start:block_end] = label
    return block_seq


def get_label(block: np.ndarray) -> int:
    """
    For a given block it returns the label. This label represents the most
    common grouping in this block. If two labels are most common, they get
    concatenated. If more than two groupings represent the block, 9 is returned.

    :param block: Mapped Sequence of a block.
    :type block: np.ndarray
    :return: Label representing the most commong group in the block.
    :rtype: int
    """
    counts = Counter(block)
    length = len(block)
    most_common_key = counts.most_common(1)[0][0]
    most_common_key_value = counts.most_common(1)[0][1]
    if most_common_key_value / length > 0.66:
        return most_common_key
    second_most_common_key = counts.most_common(2)[1][0]
    second_most_common_key_value = counts.most_common(2)[1][1]
    if (most_common_key_value + second_most_common_key_value) / length > 0.66:
        return int(f"{most_common_key}{second_most_common_key}")
    else:
        return 9


def map_sequence(sequence: str, mapping: dict) -> np.ndarray:
    """
    Returns the mapped sequence.

    :param sequence: Amino Acid sequence.
    :type sequence: str
    :param mapping: Mapping for the Amino Acid sequence.
    :type mapping: dict
    :return: Array containing the mapped sequence.
    :rtype: np.ndarray
    """
    return np.array([mapping.get(char) for char in sequence])


class TestGetLabel(unittest.TestCase):
    def test_one_label(self):
        result = get_label(np.array([5, 5, 5, 5, 4, 3, 5]))
        expected = 5
        self.assertEqual(result, expected)

    def test_two_labels(self):
        result = get_label(np.array([5, 5, 3, 5, 3, 3, 5]))
        expected = 53
        self.assertEqual(result, expected)

    def test_else_label(self):
        result = get_label(np.array([3, 4, 2, 3, 1, 2, 4]))
        expected = 9
        self.assertEqual(result, expected)


class TestMapSequence(unittest.TestCase):
    def test_mapping(self):
        result = map_sequence("ABCD", {"A": 3, "B": 1, "C": 2, "D": 3})
        expected = np.array([3, 1, 2, 3])
        np.array_equal(result, expected)


class TestGetBlockSeq(unittest.TestCase):
    def test_one_block(self):
        result = get_block_seq("ABCDDDCBA", [(3, 6)], {"A": 3, "B": 1, "C": 2, "D": 3})
        expected = np.array([-1, -1, -1, 3, 3, 3, -1, -1, -1])
        self.assertTrue(np.array_equal(result, expected))

    def test_two_blocks(self):
        result = get_block_seq(
            "ABCDDDCBABAB", [(3, 6), (8, 12)], {"A": 3, "B": 1, "C": 2, "D": 3}
        )
        expected = np.array([-1, -1, -1, 3, 3, 3, -1, -1, 31, 31, 31, 31])
        self.assertTrue(np.array_equal(result, expected))


class TestGetScalarValue(unittest.TestCase):
    def test_scalar_values(self):
        result = get_scalar_values(
            np.array([-1, -1, -1, 3, 3, 3, -1, -1, 31, 31, 31, 31]),
            {"A": 3, "B": 1, "C": 2, "D": 3},
        )
        expected = [3 / 12, 0, 0, 4 / 12, 0, 0, 0, 0, 0, 0, 5 / 12]
        self.assertEqual(result, expected)


if __name__ == "__main__":
    unittest.main()
