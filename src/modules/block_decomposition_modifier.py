import unittest
from collections import Counter

import numpy as np


def get_block_seq(
    sequence: str, block_list: list[tuple[int, int]], mapping: dict
) -> np.ndarray:
    """
    Modifies the output of the block decomposition algorithm to be more useful
    for artificial intelligence model training.

    :param sequence: Protein Sequence as String
    :type sequence: str
    :param block_list: Block List generated by the block decomposition
    algorithm.
    :type block_list: list[tuple[int, int]]
    :param mapping: Mapping used for the block decomposition.
    :type mapping: dict
    :return: Array that represents the block decomposition, were every block is
    a part of the sequence with its label.
    :rtype: np.ndarray
    """
    block_seq = np.zeros(len(sequence))
    mapped_sequence = map_sequence(sequence, mapping)
    for block in block_list:
        block_start = block[0]
        block_end = block[1]
        label = get_label(mapped_sequence[block_start:block_end])
        block_seq[block_start:block_end] = label
    return block_seq


def get_label(block: np.ndarray) -> int:
    """
    For a given block it returns the label. This label represents the most
    common grouping in this block. If two labels are most common, they get
    concatenated. If more than two groupings represent the block, 9 is returned.

    :param block: Mapped Sequence of a block.
    :type block: np.ndarray
    :return: Label representing the most commong group in the block.
    :rtype: int
    """
    counts = Counter(block)
    length = len(block)
    most_common_key = counts.most_common(1)[0][0]
    most_common_key_value = counts.most_common(1)[0][1]
    if most_common_key_value / length > 0.66:
        return most_common_key
    second_most_common_key = counts.most_common(2)[1][0]
    second_most_common_key_value = counts.most_common(2)[1][1]
    if (most_common_key_value + second_most_common_key_value) / length > 0.66:
        if most_common_key < second_most_common_key:
            return int(f"{most_common_key}{second_most_common_key}")
        else:
            return int(f"{second_most_common_key}{most_common_key}")
    else:
        return 9


def map_sequence(sequence: str, mapping: dict) -> np.ndarray:
    """
    Returns the mapped sequence.

    :param sequence: Amino Acid sequence.
    :type sequence: str
    :param mapping: Mapping for the Amino Acid sequence.
    :type mapping: dict
    :return: Array containing the mapped sequence.
    :rtype: np.ndarray
    """
    return np.array([mapping.get(char) for char in sequence])


class TestGetLabel(unittest.TestCase):
    def test_one_label(self):
        result = get_label(np.array([5, 5, 5, 5, 4, 3, 5]))
        expected = 5
        self.assertEqual(result, expected)

    def test_two_labels(self):
        result = get_label(np.array([5, 5, 3, 5, 3, 3, 5]))
        expected = 35
        self.assertEqual(result, expected)

    def test_else_label(self):
        result = get_label(np.array([3, 4, 2, 3, 1, 2, 4]))
        expected = 9
        self.assertEqual(result, expected)


class TestMapSequence(unittest.TestCase):
    def test_mapping(self):
        result = map_sequence("ABCD", {"A": 3, "B": 1, "C": 2, "D": 3})
        expected = np.array([3, 1, 2, 3])
        np.array_equal(result, expected)


class TestGetBlockSeq(unittest.TestCase):
    def test_one_block(self):
        result = get_block_seq("ABCDDDCBA", [(3, 6)], {"A": 3, "B": 1, "C": 2, "D": 3})
        expected = np.array([0, 0, 0, 3, 3, 3, 0, 0, 0])
        np.array_equal(result, expected)

    def test_two_blocks(self):
        result = get_block_seq(
            "ABCDDDCBABAB", [(3, 6), (8, 12)], {"A": 3, "B": 1, "C": 2, "D": 3}
        )
        expected = np.array([0, 0, 0, 3, 3, 3, 0, 0, 12, 12, 12, 12, 12])
        np.array_equal(result, expected)


if __name__ == "__main__":
    unittest.main()
